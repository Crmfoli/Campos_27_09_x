<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dados dos Sensores</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; background-color: #f4f6f9; margin: 0; padding: 0; }
        header { background-color: #007bff; color: white; padding: 15px; text-align: center; font-size: 22px; }
        .container { width: 90%; margin: 20px auto; }
        .grafico-container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 20px; }
        table { width: 100%; border-collapse: collapse; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        table th, table td { border: 1px solid #ddd; padding: 10px; text-align: center; }
        table th { background-color: #007bff; color: white; }
        .loading { text-align: center; padding: 20px; font-size: 18px; color: #333; }
        h2 { text-align: center; color: #333; font-weight: 500; }
    </style>
</head>
<body>
    <header>投 Dados de Monitoramento</header>

    <div class="container">
        <!-- Grﾃ｡fico para o novo arquivo (pluviometria, sucﾃｧﾃ｣o, temperatura) -->
        <div class="grafico-container">
            <h2>Estaﾃｧﾃ｣o Meteorolﾃｳgica</h2>
            <canvas id="graficoPluviometria"></canvas>
        </div>

        <!-- Grﾃ｡fico para os sensores de umidade -->
        <div class="grafico-container">
            <h2>Umidade do Solo</h2>
            <canvas id="graficoSensores"></canvas>
        </div>

        <div id="tabela-container">
            <div class="loading">A carregar dados...</div>
        </div>
    </div>

    <script>
        // --- Variﾃ｡veis e Configuraﾃｧﾃｵes Globais ---
        let todosOsDadosSensores = [], indiceAtualSensores = 0, dadosNaTelaSensores = [], graficoSensores = null;
        let todosOsDadosPluviometria = [], indiceAtualPluviometria = 0, dadosNaTelaPluviometria = [], graficoPluviometria = null;
        let intervalId = null;

        // Estilos para o grﾃ｡fico de SENSORES DE UMIDADE
        const ESTILOS_SENSORES = [
            { color: 'rgb(128, 0, 128)', pointStyle: 'circle' }, { color: 'rgb(0, 0, 255)', pointStyle: 'circle' },
            { color: 'rgb(0, 128, 0)', pointStyle: 'rect' }, { color: 'rgb(255, 165, 0)', pointStyle: 'triangle' },
            { color: 'rgb(255, 0, 0)', pointStyle: 'rectRot' }, { color: 'rgb(255, 0, 255)', pointStyle: 'star' }
        ];
        const LABELS_PROFUNDIDADE = ['Profundidade 0,3 m', 'Profundidade 0,8 m', 'Profundidade 1,5 m', 'Profundidade 2,0 m', 'Profundidade 2,5 m'];

        // ALTERAﾃﾃグ: Estilos para o novo grﾃ｡fico da ESTAﾃﾃグ METEOROLﾃ敵ICA
        const ESTILOS_ESTACAO = [
            { color: 'rgb(54, 162, 235)', pointStyle: 'rect' },    // Precipitaﾃｧﾃ｣o
            { color: 'rgb(75, 192, 192)', pointStyle: 'triangle' },// Sucﾃｧﾃ｣o
            { color: 'rgb(255, 99, 132)', pointStyle: 'star' }     // ﾂｰC Temp_Solo
        ];

        const verticalLinePlugin = {
          id: 'verticalLine',
          afterDraw: (chart) => { if (chart.tooltip?._active?.length) { const ctx = chart.ctx; const x = chart.tooltip._active[0].element.x; const topY = chart.scales.y.top; const bottomY = chart.scales.y.bottom; ctx.save(); ctx.beginPath(); ctx.moveTo(x, topY); ctx.lineTo(x, bottomY); ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)'; ctx.stroke(); ctx.restore(); } }
        };
        
        // --- Funﾃｧﾃｵes de Carregamento e Inicializaﾃｧﾃ｣o ---

        async function carregarTodosOsDados() {
            try {
                // Carrega os dois conjuntos de dados em paralelo
                const [responseSensores, responsePluviometria] = await Promise.all([
                    fetch("/dados_json"),
                    fetch("/pluviometria_json")
                ]);
                todosOsDadosSensores = await responseSensores.json();
                todosOsDadosPluviometria = await responsePluviometria.json();

                if (todosOsDadosSensores.error || todosOsDadosPluviometria.error) {
                    document.getElementById("tabela-container").innerHTML = `<div class="loading">Erro: ${todosOsDadosSensores.error || todosOsDadosPluviometria.error}</div>`;
                    return;
                }
                
                // Inicia as visualizaﾃｧﾃｵes
                iniciarVisualizacaoSensores();
                iniciarVisualizacaoPluviometria();
                
                intervalId = setInterval(adicionarProximoDado, 2000);

            } catch (error) {
                document.getElementById("tabela-container").innerHTML = `<div class="loading">Erro de conexﾃ｣o: ${error}</div>`;
            }
        }

        function iniciarVisualizacaoSensores() {
            const cabecalho = Object.keys(todosOsDadosSensores[0]);
            criarTabelaComCabecalho(cabecalho);
            iniciarGraficoSensores(cabecalho);
        }

        function iniciarVisualizacaoPluviometria() {
            const cabecalho = Object.keys(todosOsDadosPluviometria[0]);
            iniciarGraficoPluviometria(cabecalho);
        }

        function criarTabelaComCabecalho(colunas) {
            const container = document.getElementById('tabela-container');
            container.innerHTML = `<h2>Dados dos Sensores de Umidade</h2><table><thead><tr>${colunas.map(col => `<th>${col}</th>`).join('')}</tr></thead><tbody></tbody></table>`;
        }

        // --- Funﾃｧﾃｵes dos Grﾃ｡ficos ---

        function iniciarGraficoSensores(colunas) {
            const ctx = document.getElementById('graficoSensores').getContext('2d');
            const datasets = colunas.slice(1).map((col, i) => ({
                label: LABELS_PROFUNDIDADE[i] || col, data: [], borderColor: ESTILOS_SENSORES[i].color, backgroundColor: ESTILOS_SENSORES[i].color,
                pointStyle: ESTILOS_SENSORES[i].pointStyle, pointRadius: 5, pointHoverRadius: 7, tension: 0.1, fill: false
            }));
            graficoSensores = new Chart(ctx, {
                type: 'line', data: { labels: [], datasets: datasets },
                options: { responsive: true, interaction: { mode: 'index', intersect: false }, plugins: { legend: { position: 'bottom' } }, scales: { x: { ticks: { maxRotation: 45, minRotation: 45 } }, y: { title: { display: true, text: 'Umidade Volumetrica (%)' } } } },
                plugins: [verticalLinePlugin]
            });
        }

        // ALTERAﾃﾃグ: Grﾃ｡fico de linha para mﾃｺltiplos dados da estaﾃｧﾃ｣o
        function iniciarGraficoPluviometria(colunas) {
            const ctx = document.getElementById('graficoPluviometria').getContext('2d');
            const datasets = colunas.slice(1).map((col, i) => ({
                label: col, data: [], borderColor: ESTILOS_ESTACAO[i % ESTILOS_ESTACAO.length].color, backgroundColor: ESTILOS_ESTACAO[i % ESTILOS_ESTACAO.length].color,
                pointStyle: ESTILOS_ESTACAO[i % ESTILOS_ESTACAO.length].pointStyle, pointRadius: 5, pointHoverRadius: 7, tension: 0.1, fill: false
            }));
            graficoPluviometria = new Chart(ctx, {
                type: 'line', // Alterado para 'line'
                data: { labels: [], datasets: datasets },
                options: { responsive: true, interaction: { mode: 'index', intersect: false }, plugins: { legend: { position: 'bottom' } }, scales: { x: { ticks: { maxRotation: 45, minRotation: 45 } }, y: { title: { display: true, text: 'Valores' }, beginAtZero: false } } },
                plugins: [verticalLinePlugin]
            });
        }

        // --- Funﾃｧﾃｵes de Atualizaﾃｧﾃ｣o (Loop) ---

        function adicionarProximoDado() {
            let continuar = false;
            // Atualiza dados dos sensores
            if (indiceAtualSensores < todosOsDadosSensores.length) {
                dadosNaTelaSensores.unshift(todosOsDadosSensores[indiceAtualSensores++]); 
                if (dadosNaTelaSensores.length > 10) dadosNaTelaSensores.pop();
                continuar = true;
            }
            // Atualiza dados da estaﾃｧﾃ｣o
            if (indiceAtualPluviometria < todosOsDadosPluviometria.length) {
                dadosNaTelaPluviometria.unshift(todosOsDadosPluviometria[indiceAtualPluviometria++]);
                if (dadosNaTelaPluviometria.length > 10) dadosNaTelaPluviometria.pop();
                continuar = true;
            }

            renderizarTabelaSensores(); 
            atualizarGraficoSensores();
            atualizarGraficoPluviometria();

            if (!continuar) clearInterval(intervalId);
        }

        function renderizarTabelaSensores() {
            const tbody = document.querySelector("#tabela-container table tbody");
            if (!tbody) return;
            tbody.innerHTML = dadosNaTelaSensores.map(linha => `<tr>${Object.values(linha).map(val => `<td>${val === null ? '' : val}</td>`).join('')}</tr>`).join('');
        }

        function atualizarGraficoSensores() {
            if (!graficoSensores || dadosNaTelaSensores.length === 0) return;
            const dadosParaGrafico = [...dadosNaTelaSensores].reverse();
            const labelKey = Object.keys(dadosParaGrafico[0])[0];
            graficoSensores.data.labels = dadosParaGrafico.map(d => d[labelKey]);
            Object.keys(dadosParaGrafico[0]).slice(1).forEach((coluna, index) => {
                if (graficoSensores.data.datasets[index])
                    graficoSensores.data.datasets[index].data = dadosParaGrafico.map(d => d[coluna]);
            });
            graficoSensores.update(); 
        }

        // ALTERAﾃﾃグ: Atualiza todas as linhas do grﾃ｡fico da estaﾃｧﾃ｣o
        function atualizarGraficoPluviometria() {
            if (!graficoPluviometria || dadosNaTelaPluviometria.length === 0) return;
            const dadosParaGrafico = [...dadosNaTelaPluviometria].reverse();
            const labelKey = Object.keys(dadosParaGrafico[0])[0];
            graficoPluviometria.data.labels = dadosParaGrafico.map(d => d[labelKey]);
            Object.keys(dadosParaGrafico[0]).slice(1).forEach((coluna, index) => {
                if (graficoPluviometria.data.datasets[index])
                    graficoPluviometria.data.datasets[index].data = dadosParaGrafico.map(d => d[coluna]);
            });
            graficoPluviometria.update();
        }
        
        carregarTodosOsDados();
    </script>
</body>
</html>
