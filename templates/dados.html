<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dados dos Sensores</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; background-color: #f4f6f9; margin: 0; padding: 0; }
        header { background-color: #007bff; color: white; padding: 15px; text-align: center; font-size: 22px; }
        .container { width: 90%; margin: 20px auto; }
        .grafico-container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 20px; }
        table { width: 100%; border-collapse: collapse; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        table th, table td { border: 1px solid #ddd; padding: 10px; text-align: center; }
        table th { background-color: #007bff; color: white; }
        .loading { text-align: center; padding: 20px; font-size: 18px; color: #333; }
        h2 { text-align: center; color: #333; font-weight: 500; }
    </style>
</head>
<body>
    <header>üìä Dados de Monitoramento</header>

    <div class="container">
        <div class="grafico-container">
            <h2>Esta√ß√£o Meteorol√≥gica</h2>
            <canvas id="graficoPluviometria"></canvas>
        </div>

        <div class="grafico-container">
            <h2>Umidade do Solo</h2>
            <canvas id="graficoSensores"></canvas>
        </div>

        <div id="tabela-container">
            <div class="loading">A carregar visualiza√ß√£o...</div>
        </div>
    </div>

    <script>
        // --- Vari√°veis Globais ---
        let todosOsDadosSensores = [], indiceAtualSensores = 0, dadosNaTelaSensores = [], graficoSensores = null;
        let todosOsDadosPluviometria = [], indiceAtualPluviometria = 0, dadosNaTelaPluviometria = [], graficoPluviometria = null;
        let intervalId = null;

        // --- Configura√ß√µes de Estilo dos Gr√°ficos ---
        const ESTILOS_SENSORES = [
            { color: 'rgb(128, 0, 128)', pointStyle: 'circle' }, { color: 'rgb(0, 0, 255)', pointStyle: 'circle' },
            { color: 'rgb(0, 128, 0)', pointStyle: 'rect' }, { color: 'rgb(255, 165, 0)', pointStyle: 'triangle' },
            { color: 'rgb(255, 0, 0)', pointStyle: 'rectRot' }, { color: 'rgb(255, 0, 255)', pointStyle: 'star' }
        ];
        const LABELS_PROFUNDIDADE = ['Profundidade 0,3 m', 'Profundidade 0,8 m', 'Profundidade 1,5 m', 'Profundidade 2,0 m', 'Profundidade 2,5 m'];
        const ESTILOS_ESTACAO = {
            'Precipita√ß√£o': { type: 'bar', color: 'rgba(54, 162, 235, 0.6)', borderColor: 'rgba(54, 162, 235, 1)', yAxisID: 'y' },
            'Precipita√ß√£o Acumulada': { type: 'line', color: 'rgb(0, 0, 0)', borderColor: 'rgb(0, 0, 0)', yAxisID: 'y1' },
            'Suc√ß√£o': { type: 'line', color: 'rgb(75, 192, 192)', borderColor: 'rgb(75, 192, 192)', yAxisID: 'y1' },
            '¬∞C Temp_Solo': { type: 'line', color: 'rgb(255, 99, 132)', borderColor: 'rgb(255, 99, 132)', yAxisID: 'y1' }
        };
        const defaultEstacaoStyle = { type: 'line', color: 'rgb(100, 100, 100)', yAxisID: 'y1' };
        const verticalLinePlugin = {
          id: 'verticalLine',
          afterDraw: (chart) => { if (chart.tooltip?._active?.length) { const ctx = chart.ctx; const x = chart.tooltip._active[0].element.x; const topY = chart.scales.y.top; const bottomY = chart.scales.y.bottom; ctx.save(); ctx.beginPath(); ctx.moveTo(x, topY); ctx.lineTo(x, bottomY); ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)'; ctx.stroke(); ctx.restore(); } }
        };
        
        // --- L√ìGICA DE CARREGAMENTO OTIMIZADA ---

        async function iniciarTudo() {
            try {
                // ETAPA 1: Carrega os dados iniciais (r√°pido)
                const [respIniciaisSensores, respIniciaisPluviometria] = await Promise.all([
                    fetch("/dados_iniciais"),
                    fetch("/pluviometria_iniciais")
                ]);
                todosOsDadosSensores = await respIniciaisSensores.json();
                todosOsDadosPluviometria = await respIniciaisPluviometria.json();

                if (todosOsDadosSensores.error || todosOsDadosPluviometria.error) throw new Error(todosOsDadosSensores.error || todosOsDadosPluviometria.error);
                if (todosOsDadosSensores.length === 0 || todosOsDadosPluviometria.length === 0) throw new Error("Os arquivos de dados iniciais est√£o vazios.");


                // ETAPA 2: Inicia a visualiza√ß√£o imediatamente com os dados iniciais
                iniciarVisualizacaoSensores();
                iniciarVisualizacaoPluviometria();
                intervalId = setInterval(adicionarProximoDado, 2000);

                // ETAPA 3: Busca os dados completos em segundo plano
                carregarDadosCompletos();

            } catch (error) {
                document.getElementById("tabela-container").innerHTML = `<div class="loading">Erro ao iniciar: ${error.message}</div>`;
            }
        }

        async function carregarDadosCompletos() {
            try {
                const [respCompletosSensores, respCompletosPluviometria] = await Promise.all([
                    fetch("/dados_json"),
                    fetch("/pluviometria_json")
                ]);
                const dadosCompletosSensores = await respCompletosSensores.json();
                const dadosCompletosPluviometria = await respCompletosPluviometria.json();

                if (dadosCompletosSensores.error || dadosCompletosPluviometria.error) {
                    console.error("Erro ao buscar dados completos:", dadosCompletosSensores.error || dadosCompletosPluviometria.error);
                    return; // Continua com os dados iniciais se houver erro
                }
                
                // ETAPA 4: Substitui os dados iniciais pelos completos de forma transparente
                todosOsDadosSensores = dadosCompletosSensores;
                todosOsDadosPluviometria = dadosCompletosPluviometria;
                console.log("Dados completos carregados em segundo plano.");

            } catch (error) {
                 console.error("Falha ao carregar dados completos em segundo plano:", error);
            }
        }


        // --- Fun√ß√µes de Inicializa√ß√£o dos Gr√°ficos e Tabela ---

        function iniciarVisualizacaoSensores() {
            const cabecalho = Object.keys(todosOsDadosSensores[0]);
            criarTabelaComCabecalho(cabecalho);
            iniciarGraficoSensores(cabecalho);
        }

        function iniciarVisualizacaoPluviometria() {
            const cabecalho = Object.keys(todosOsDadosPluviometria[0]);
            iniciarGraficoPluviometria(cabecalho);
        }

        function criarTabelaComCabecalho(colunas) {
            const container = document.getElementById('tabela-container');
            container.innerHTML = `<h2>Dados dos Sensores de Umidade</h2><table><thead><tr>${colunas.map(col => `<th>${col}</th>`).join('')}</tr></thead><tbody></tbody></table>`;
        }

        function iniciarGraficoSensores(colunas) {
            const ctx = document.getElementById('graficoSensores').getContext('2d');
            const datasets = colunas.slice(1).map((col, i) => ({
                label: LABELS_PROFUNDIDADE[i] || col, data: [], borderColor: ESTILOS_SENSORES[i].color, backgroundColor: ESTILOS_SENSORES[i].color,
                pointStyle: ESTILOS_SENSORES[i].pointStyle, pointRadius: 5, tension: 0.1, fill: false
            }));
            graficoSensores = new Chart(ctx, {
                type: 'line', data: { labels: [], datasets: datasets },
                options: { responsive: true, interaction: { mode: 'index', intersect: false }, plugins: { legend: { position: 'bottom' } }, scales: { x: { ticks: { maxRotation: 45, minRotation: 45 } }, y: { title: { display: true, text: 'Umidade Volumetrica (%)' } } } },
                plugins: [verticalLinePlugin]
            });
        }

        function iniciarGraficoPluviometria(colunas) {
            const ctx = document.getElementById('graficoPluviometria').getContext('2d');
            const labelKey = 'data_hora';
            const dataColumns = colunas.filter(col => col !== labelKey);
            const datasets = dataColumns.map(col => {
                const estilo = ESTILOS_ESTACAO[col] || defaultEstacaoStyle;
                return {
                    label: col, data: [], type: estilo.type, borderColor: estilo.borderColor,
                    backgroundColor: estilo.color, tension: 0.1, fill: false, yAxisID: estilo.yAxisID
                };
            });

            graficoPluviometria = new Chart(ctx, {
                type: 'bar', data: { labels: [], datasets: datasets },
                options: { 
                    responsive: true, interaction: { mode: 'index', intersect: false }, 
                    plugins: { legend: { position: 'bottom' } }, 
                    scales: { 
                        x: { ticks: { maxRotation: 45, minRotation: 45 } }, 
                        y: { position: 'left', title: { display: true, text: 'Precipita√ß√£o (mm)' }, beginAtZero: true },
                        y1: { position: 'right', title: { display: true, text: 'Outros Valores' }, beginAtZero: false, grid: { drawOnChartArea: false } }
                    } 
                },
                plugins: [verticalLinePlugin]
            });
        }

        // --- Fun√ß√µes de Atualiza√ß√£o (Loop Principal) ---

        function adicionarProximoDado() {
            let continuarAnimacao = false;
            
            if (indiceAtualSensores < todosOsDadosSensores.length) {
                dadosNaTelaSensores.unshift(todosOsDadosSensores[indiceAtualSensores++]); 
                if (dadosNaTelaSensores.length > 10) dadosNaTelaSensores.pop();
                continuarAnimacao = true;
            }
            if (indiceAtualPluviometria < todosOsDadosPluviometria.length) {
                dadosNaTelaPluviometria.unshift(todosOsDadosPluviometria[indiceAtualPluviometria++]);
                if (dadosNaTelaPluviometria.length > 10) dadosNaTelaPluviometria.pop();
                continuarAnimacao = true;
            }

            renderizarTabelaSensores(); 
            atualizarGraficoSensores();
            atualizarGraficoPluviometria();

            if (!continuarAnimacao) clearInterval(intervalId);
        }

        function renderizarTabelaSensores() {
            const tbody = document.querySelector("#tabela-container table tbody");
            if (tbody) tbody.innerHTML = dadosNaTelaSensores.map(linha => `<tr>${Object.values(linha).map(val => `<td>${val === null ? '' : val}</td>`).join('')}</tr>`).join('');
        }

        function atualizarGrafico(grafico, dadosNaTela, labelKeyOverride = null) {
            if (!grafico || dadosNaTela.length === 0) return;
            const dadosParaGrafico = [...dadosNaTela].reverse();
            const labelKey = labelKeyOverride || Object.keys(dadosParaGrafico[0])[0];
            
            grafico.data.labels = dadosParaGrafico.map(d => d[labelKey]);
            grafico.data.datasets.forEach(dataset => {
                const columnName = dataset.label;
                dataset.data = dadosParaGrafico.map(d => d[columnName]);
            });
            grafico.update();
        }

        const atualizarGraficoSensores = () => atualizarGrafico(graficoSensores, dadosNaTelaSensores);
        const atualizarGraficoPluviometria = () => atualizarGrafico(graficoPluviometria, dadosNaTelaPluviometria, 'data_hora');
        
        // Inicia todo o processo
        iniciarTudo();
    </script>
</body>
</html>
